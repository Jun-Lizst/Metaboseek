#' @title MseekWidgets
#'
#' @description \code{MseekWidgets} should work in a "vanilla" shiny environment, i.e. any shiny app, making it
#'  easy to use them in other shiny projects without significant overhead. The only expected argument 
#'  they need is a list supplied as reactives, and potentially additional arguments for which default
#'   values exist. Widgets are typically wrappers for plotting functions with some additional functionality. 
#'   
#' @param input,output,session arguments necessary for use with \link[shiny]{callModule}()
#' @param reactives a list, wrapped in a \link[shiny]{reactive}() expression with settings for this module. See \code{details}.
#' @param id id to be used to define a namespace via  \link[shiny]{NS}() (must match \code{id} in \link[shiny]{callModule} for the server Module)
#' @param ... additional arguments, as defined for the individual module. For example: constant layout options depending on the context that this module is used in
#' 
#' @describeIn MseekWidgets generic server logic example for MseekWidgets
MseekWidgets <- function(input,output, session, reactives, ...){
    
    #creating the namespacing function to be used for UI elements that are prepared inside the server logic
    ns <- NS(session$ns(NULL))
    
    #optional: a local reactiveValues() object to be used to exchange information within this module
    internalValues <- reactiveValues()
    
    #optional: expose the internalValues to the outside. Makes it possible to change them from outside the module!
    return(internalValues)
    
}

#' @describeIn MseekWidgets generic UI example for MseekWidgets
MseekWidgetsUI <- function(id){
    
    #basic wrapper for UI elements that will embed the contained UI elements directly into the surrounding UI without placing them inside another div.
    shiny::tagList(
        #place UI elements here
        )
    #Other options include shiny::fluidPage(), shiny::div() or shiny::box()

}

#' @title MseekModules
#'
#' @description Regular modules in Metaboseek take a `shiny::reactiveValues` object called `values` as their first argument.
#'  `values` is the primary interface allowing communication between modules and is generated by `MseekMinimalServer()`.
#'   Modules expect this input to work properly, and will only work in shiny apps that provide the proper environment set up by `MseekMinimalServer()`.
#'   
#' @param input,output,session arguments necessary for use with \link[shiny]{callModule}()
#' @param values a \link[shiny]{reactiveValues} object that in effect gives read and write access to external objects
#' @param reactives a list, wrapped in a \link[shiny]{reactive}() expression with settings for this module. See \code{details}.
#' @param id id to be used to define a namespace via  \link[shiny]{NS}() (must match \code{id} in \link[shiny]{callModule} for the server Module)
#' @param ... additional arguments, as defined for the individual module. For example: constant layout options depending on the context that this module is used in
#' 
#' @describeIn MseekModules generic server logic example for MseekModules
MseekModules <- function(input,output, session, values, reactives, ...){
    
    #creating the namespacing function to be used for UI elements that are prepared inside the server logic
    ns <- NS(session$ns(NULL))
    
    #optional: a local reactiveValues() object to be used to exchange information within this module
    internalValues <- reactiveValues()
    
    #optional: expose the internalValues to the outside. Makes it possible to change them from outside the module!
    return(internalValues)

}

#' @describeIn MseekModules generic UI example for MseekModules
MseekModulesUI <- function(id){
    
    #basic wrapper for UI elements that will embed the contained UI elements directly into the surrounding UI without placing them inside another div.
    shiny::tagList(
        #place UI elements here
    )
    #Other options include shiny::fluidPage(), shiny::div() or shiny::box()
    
}

#' @title MseekContainers
#'
#' @description Regular modules in Metaboseek take a `shiny::reactiveValues` object called `values` as their first argument.
#'  `values` is the primary interface allowing communication between modules and is generated by `MseekMinimalServer()`.
#'   Modules expect this input to work properly, and will only work in shiny apps that provide the proper environment set up by `MseekMinimalServer()`.
#'   
#' @param input,output,session arguments necessary for use with \link[shiny]{callModule}()
#' @param values a \link[shiny]{reactiveValues} object that in effect gives read and write access to external objects
#' @param id id to be used to define a namespace via  \link[shiny]{NS}() (must match \code{id} in \link[shiny]{callModule} for the server Module)
#' 
#' @describeIn MseekContainers generic server logic example for MseekContainers
MseekContainers <- function(input,output, session, values){
    
    #creating the namespacing function to be used for UI elements that are prepared inside the server logic
    ns <- NS(session$ns(NULL))
    
    #optional: a local reactiveValues() object to be used to exchange information within this module
    internalValues <- reactiveValues()
    
    #optional: expose the internalValues to the outside. Makes it possible to change them from outside the module!
    return(internalValues)
    
}

#' @describeIn MseekContainers generic UI example for MseekContainers
MseekContainersUI <- function(id){
    
    #basic wrapper for UI elements that will embed the contained UI elements directly into the surrounding UI without placing them inside another div.
    shiny::tagList(
        #place UI elements here
    )
    #Other options include shiny::fluidPage(), shiny::div() or shiny::box()
    
}
