#' analyzeTable
#'
#' Run a series of analyses on a feature table data.frame
#'
#' @param df a data.frame with numeric (intensity) values, rt and mz values
#' @param intensities the intensity column names, before normalization (without __norm suffix), will be automatically renamed if useNormalized.
#' @param groups named list of non-normalized intensity columns listed by group (as supplied by $anagroupnames of MosaicFT objects), will be automatically renamed if useNormalized.
#' @param analyze character vector to select the analyses to be run: "Basic analysis", "clara_cluster", "p-values", "Peak shapes"
#' @param normalize normalze intensity columns
#' @param useNormalize use normalized values for analyses; will trigger normalize if there is no normalized data available for all selected intensity columns
#' @param MSData a (named) list of xcmsRaw objects, e.g. generated by Mosaic::loadRawM, OR an MSnbase OnDiskMSnExp object required for peak shape analysis
#' @param ppm ppm range for peak shape analysis
#' @param controlGroup control group for foldChange (part of Basic analysis) analysis (optional) 
#' @param numClusters number of clusters for clara_clusters analysis
#'
#' @importFrom stats prcomp 
#'
analyzeTable <- function(df = tab1$df, intensities = tab1$intensities,
                         groups = tab1$anagroupnames,
                         analyze = c("Basic analysis", "clara_cluster", "p-values", "Peak shapes", "PCA features", "PCA samples"), 
                         normalize = T, useNormalized = T, MSData = NULL, ppm = 5, controlGroup = NULL, numClusters = 2){
  out <- list(errmsg = list())
  
  if(normalize 
     || (useNormalized && !identical(grep("__norm",colnames(df), value = T), paste0(intensities,"__norm")))
  ){
    #normalize data and save it in matrix
    mx <- as.matrix(df[,intensities])
    mx <- featureTableNormalize(mx,
                                raiseZeros =  min(mx[which(!mx==0, arr.ind=T)]))
    # mx <- featureTableNormalize(mx, log =  "log10")
    mx <- featureTableNormalize(mx, normalize = "colMeans")
    #make copy of normalized intensities in active table df
    mx <- as.data.frame(mx)
    colnames(mx) <- paste0(colnames(mx),"__norm")
    df <- updateDF (mx,df)
    
  }
  
  if(useNormalized){
    intensities <- paste0(intensities,"__norm")
    groups <- lapply(groups, paste0, "__norm")
  }
  
  if("Peak shapes" %in% analyze){
    if(is.null(MSData)){
      out$errmsg[["Peak shapes"]] <- "Peak shapes analysis was not performed because no MS data is loaded."
      
    }else if (!"mz" %in% colnames(df) || !"rt" %in% colnames(df)){
      out$errmsg[["Peak shapes"]] <- "Peak shapes analysis was not performed because table does not contain 'rt' and 'mz' columns."
    }else{
      inp <- bestgauss(
        rawdata= MSData,
        mz = data.frame(mzmin = df$mz-ppm*1e-6*df$mz, mzmax=df$mz+ppm*1e-6*df$mz),
        rt = data.frame(rtmin = df$rt-5, rtmax=df$rt+5),
        rnames = row.names(df)
      )
      
      df <- updateDF (inp, df)
      
    }}
  
  if("Basic analysis" %in% analyze){
    df <- updateDF(featureCalcs(df),
                   df)
    
    # if(is.null(groups)){
    #   out$errmsg[["Basic analysis"]] <- "Fold change analysis was not performed because no grouping information is loaded."
    #   
    # }else if (length(groups) == 1){
    #   out$errmsg[["Basic analysis"]] <- "Fold change analysis was not performed because there is only one sample group."
    # }else{
    df <- updateDF(foldChange(as.matrix(df[,intensities]),
                                 groups, ctrl = controlGroup),
                   df)
    # }
  }
  
  if("p-values" %in% analyze){
    
    df <- updateDF(multittest(df = df[,intensities],
                                 groups,
                                 ttest = T,
                                 adjmethod = "bonferroni"),
                   df)
    
  }
  
  
  if("clara_cluster" %in% analyze){
    
    if(length(intensities) <2 ){
      out$errmsg[["clara_cluster"]] <- "Clara cluster analysis was not performed because there is only one sample."
    }else{
      
      mx <- sqrt(as.matrix(df[,intensities])) #using sqrt here to condense data values which may contain 0s
      
      
      df <- updateDF(MosCluster(x = mx / rowMeans(mx),
                                   k = numClusters,
                                   samples = 100), 
                     df)
    }
    
  }
  
  if("PCA features" %in% analyze){
    pcamemx <- as.matrix(df[,intensities])
    
    pcamemx <- scale(pcamemx, center = T, scale = T)
    
    #PCA to separate features
    prin_comp <- prcomp(pcamemx)
    
    
    df <-updateDF(as.data.frame(prin_comp$x[,1:min(ncol(prin_comp$x),15)]), df)
    
  }
  
  if("PCA samples" %in% analyze){
    pcamemx <- t(as.matrix(df[,intensities]))
    
    pcamemx <- scale(pcamemx, center = T, scale = T)
    
    #PCA to separate features
    prin_comp <- prcomp(pcamemx)
    
    
    out$PCA_samples <- as.data.frame(prin_comp$x[,1:min(ncol(prin_comp$x), 15)])
    
  }
  
  out$df <- df
  return(out)
  
}

#' featureTableNormalize
#' 
#' Function to normalize data in a matrix.
#' 
#' 
#' @param mx a matrix of numeric (intensity) values
#' @param raiseZeros if not NULL, values of 0 will be raised to a level defined by a character string. "min" will raise all zeros to the lowest non-zero value in mx.
#' @param log if not NULL, log10 will be applied to values in mx
#' @param normalize if not NULL, column values will be normalized by column averages
#' @param threshold numeric(1). 
#' @param thresholdMethod if not NULL, removes all rows in mx in which no value is above threshold
#' 
#' @importFrom Biobase rowMax
#' 
#' @export
featureTableNormalize <- function (mx,
                      raiseZeros = NULL,#"min",
                      log = NULL,#"log10",
                      normalize = NULL,#"columnMean",
                      threshold = NULL,#0.1,
                      thresholdMethod = NULL#"rowMax"
                      ){
    
    if(!is.null(mx)){
    
    if(!is.null(raiseZeros)){
        #add switch for dirrerent options later
        mx[which(mx==0, arr.ind=T)]  <- raiseZeros
    }
    
    if(!is.null(log)){
        mx <- log10(mx)
    }
    
    if(!is.null(normalize)){
        #calculate correction factor for each column
        mxmeans <- colMeans(mx)
        mxmeans <- mxmeans/mean(mxmeans)
        #apply it
        for (i in 1:ncol(mx)){
        mx[,i] <- mx[,i]/mxmeans[i]} 
    }
    
    if(!is.null(threshold) & !is.null(thresholdMethod)){
        mx <- mx[which(rowMax(mx)>threshold),]
    }
    return(mx)
    
    }
}


#' featureCalcs
#' 
#' 
#' Calculate simple parameters from feature table data.frame
#' 
#' @param df a feature table data.frame with a column "mz"
#' @param massdef if true, calculate the mass defect for each entry in df from their mz values
#' 
#' 
#' 
#' @export
featureCalcs <- function(df,
                         massdef = T# calculate mass defect for each feature
){
  if(massdef){
    df$massdefppm <- ((df$mz-floor(df$mz))/df$mz)*1e6
  
    return(data.frame(massdefppm = df$massdefppm))
  }

    }




#' foldChange
#' 
#' 
#' calculate fold changes between grouped columns of a matrix
#' 
#' @param mx a matrix of numeric (intensity) values
#' @param groups named list of intensity columns listed by group (as supplied by $anagroupnames or $anagroupnames_norm of MosaicFT objects)
#' @param ctrl character() naming the control group(s)
#' @param calc currently has to be "mean", compare rowMeans of one group vs. rowMeans of other groups (and optionally rowMeans of controls only)
#' @param topgroup if TRUE, return group with highest intensity for each feature
#' @param maxFold if TRUE, make a column with maximum fold change between any two groups for each feature
#' @param foldMaxK if not NULL, make column with fold change of highest group value over foldMaxK largest group value.
#' @param foldmode if "complex", gives ratios between all groups
#' 
#' @importFrom Biobase rowMax rowMin rowQ
#'    
#' @export
foldChange <- function(mx,
                       groups, #
                       ctrl = NULL, #control group
                       calc = "mean", #use  rowMeans (vs. rowMean), rowMedians (vs. row), or rowMax to calculate upingroup and maxFold
                       topgroup = T, #return group with highest intensity for each feature
                       maxFold = T, #make a column with maximum fold change between any two groups for each feature
                       foldMaxK = 2, #make column with fold change of Max over kth largest
                       foldmode = "simple" #or "complex" (which gives ratios between all groups)
                       ){
    
  #needed to fix a problem where 0/0 results in NaN, which causes problems with rowQ functions
  removeNaNs <- function(mat, replacement = 1){
    mat[is.na(mat)] <- replacement
    return(mat)
  }
  
  out <- data.frame(pholder=integer(nrow(mx)))   
  out$maxint <- if(ncol(mx)==1){mx}else{rowMax(mx)}
  
  if(length(groups) >1){
  if(calc == "mean"){
    
    #make rowMeans for each group
    rme <- function(cols,mx){return(if(length(cols)==1){mx[,cols]}else{rowMeans(mx[,cols])})}
    rmeans <- sapply(groups,rme, mx)
    rmax <- function(cols,mx){return(if(length(cols)==1){mx[,cols]}else{rowMax(mx[,cols])})}
    rmaxes <- sapply(groups,rmax, mx)
    rmin <- function(cols,mx){return(if(length(cols)==1){mx[,cols]}else{rowMin(mx[,cols])})}
    rmins <- sapply(groups,rmin, mx)
    
    out$topgroup <- colnames(rmeans)[apply(rmeans,1,which.max)]
    out$maxfold <- rowMax(rmeans)/rowMin(rmeans)
    
    if(!is.null(foldMaxK)){
      k <- if(foldMaxK >= ncol(rmeans)){1}else{ncol(rmeans) - foldMaxK + 1}
      out[[paste0("maxfoldover",foldMaxK)]] <- rowMax(rmeans)/rowQ(rmeans,k)
    }
    
    #make columns for each group, fold over all the other groups, and fold over ctrl if ctrl is defined
    
    for(i in colnames(rmeans)){
      
      #remove everything after double underscore (new default notation)
      #remove the XIC tag if it has only one underscore (old notation)
      #remove trailing underscores if any
      
      barename <- gsub("_$","",gsub("_XIC","",gsub("__(.*)","",i)))
      
      out[[paste0(barename,"__meanInt")]] <- rmeans[,i]
      if(!is.null(foldmode) && foldmode=="complex"){
        out[[paste0(barename,"__foldOver_")]] <- rmeans[,i]/rmeans[,which(colnames(rmeans)!=i)]
        out[[paste0(barename,"__minFoldOver_")]] <- rmins[,i]/rmaxes[,which(colnames(rmaxes)!=i)]
      }else{
        out[[paste0(barename,"__foldOverRest")]] <- if(length(colnames(rmeans)) >2){
          unname(removeNaNs(rmeans[,i]/rowMeans(rmeans[,which(colnames(rmeans)!=i)])))
        }else{
          unname(rmeans[,i]/rmeans[,which(colnames(rmeans)!=i)])
        }
        out[[paste0(barename,"__minFold")]] <- if(length(colnames(rmeans)) >2){
          
          rowMin(removeNaNs(rmins[,i]/rmaxes[,which(colnames(rmaxes)!=i)]))  
          
          
        }else{
          rmins[,i]/rmaxes[,which(colnames(rmaxes)!=i)]
        }
        out[[paste0(barename,"__minFoldMean")]] <- if(length(colnames(rmeans)) >2){
          rowMin(removeNaNs(rmeans[,i]/rmaxes[,which(colnames(rmeans)!=i)]))  
        }else{
          rmeans[,i]/rmaxes[,which(colnames(rmeans)!=i)]
        }
      }
      
      if(!is.null(ctrl)){
        out[[paste0(barename,"__foldOverCtrl")]] <- rmeans[,i]/rmeans[,ctrl]
        out[[paste0(barename,"__minFoldOverCtrl")]] <- rmins[,i]/rmaxes[,ctrl]
      }
    }
  }
  
  
  if(is.null(foldmode) || !foldmode=="complex"){
    barenames <- gsub("_$","",gsub("_XIC","",gsub("__(.*)","",colnames(rmeans))))
    minFoldCols <- paste0(barenames,"__minFold")
    minFoldMeansCols <- paste0(barenames,"__minFoldMean")
    minFoldCtrlCols <- paste0(barenames,"__minFoldOverCtrl")
    
    out$best_minFold <- rowMax(as.matrix(removeNaNs(out[,minFoldCols])))
    out$best_minFoldMean <- rowMax(as.matrix(removeNaNs(out[,minFoldMeansCols])))
    if(!is.null(ctrl)){
      out$best_minFoldCtrl <- rowMax(as.matrix(removeNaNs(out[,minFoldCtrlCols])))

    }
    
  }
  }
  return(out[,which(colnames(out)!="pholder")])
        
       
    }
    


#' multittest
#' 
#' 
#' Calculate per-row p-values between grouped columns of a data.frame.
#' Note that for column groups with less than 2 members, a pseudo-ttest will be calculated via Mosaic::ttestx to avoid throwing errors.
#' 
#' @param df a data.frame with numeric (intensity) values
#' @param groups named list of intensity columns listed by group (as supplied by $anagroupnames or $anagroupnames_norm of MosaicFT objects)
#' @param ttest if TRUE, ttest will be calculated
#' @param adjmethod method to adjust p values (passed on to stats::p.adjust)
#'  
#' @importFrom stats p.adjust
#'  
#' @export
multittest <- function (df = as.data.frame(mx),
                    groups,
                    ttest=T,
                    adjmethod='bonferroni'){
   # withProgress(message = 'Please wait!', detail = "calculating pvalues", value = 0.03,{

    out = data.frame(pholder= numeric(nrow(df)))
    #calculate parameters for each group
    for (n in c(1:length(groups))){
        noni <- unlist(groups)[which(!unlist(groups) %in% groups[[n]])]
        i <- groups[[n]]
        
       # meanint <- rowMeans(as.matrix(df[,i]))
        #maxint <- rowMax(as.matrix(df[,i]))
        #fold2 <- rowMeans(as.matrix(df[,i]))/rowMeans(as.matrix(df[,noni]))
        sdev <- sapply(as.list(data.frame(t((df[,i])))),sd)/if(length(i)==1){df[,i]}else{rowMeans(as.matrix(df[,i]))}
       # sdev2 <- sapply(split(df[,i],seq(nrow(df))),sd)/rowMeans(as.matrix(df[,i]))
        sdev[which(is.na(sdev))] <-0 #if there is only one data point in a line, sd returns 0
        
        if(ttest){if (min(length(i),length(noni)) > 1){
            pval <- mttest(x=df[,i],y=df[,noni])}
            else{ pval <- sapply(as.list(data.frame(t((df[,c(i,noni)])))),
                                 ttestx,calc=1,over=c(2:(length(i)+length(noni))))
            pval[which(pval>0.5)] <- 1-pval[which(pval>0.5)]}
            padj <- p.adjust(pval, method = adjmethod)}
        
        
        #options(scipen = 100, digits = 4)
        
        out[[paste0(names(groups)[n],"__sdev")]] <- sdev
        
        #options(scipen = -100, digits = 4)
        out[[paste0(names(groups)[n],"__pval")]] <- pval
        out[[paste0(names(groups)[n],"__pval_adj")]] <- padj
    }
    

    return(out[,which(colnames(out) !="pholder")])
 #   })
}



#' mttest
#' 
#' helper function for multittest, calculating the p.value between two numeric vectors
#'  
#' @param x numeric vector
#' @param y numeric vector
#'  
#' @export
mttest <- function (x,y){
    
    if(nrow(x)==1){
        xl <- x
        yl <- y
        return(sttest(x=xl,y=yl)[[3]])
    }else{
    
    xl <- as.list(data.frame(t((x))))
    yl <- as.list(data.frame(t((y))))
    
    listo <- mapply(sttest,x=xl, 
                    y=yl, SIMPLIFY = F)
    
    return(sapply(listo,"[[",3))}}

#' sttest
#' 
#' helper function for mttest, calculating the p.value between two numeric vectors
#'  
#' @param out what to return if there is an error in the call to t.test, defaults to NA
#' @param ... arguments passed on to stats::t.test
#' 
#' @importFrom stats t.test
#'  
#' @export
sttest <- function(out=NA,...){
    res <-try(t.test(...), silent = T)
    if(is(res,"try-error")){return(out)}else{return(res)}
}

#' ttestx
#' 
#' Upper or Lower Tail Test of Population Mean with Unknown Variance
#'  
#' @param x numeric vector
#' @param ltail TRUE or FALSE, passed on as lower.tail to stats::pt
#' @param over indexes of values in x to be used as population
#' @param calc indexes of values in x representing the hypothesized upper bond of population mean
#' 
#' @importFrom stats sd
#'  
#' @export
ttestx <- function(x=c(1,2,2,3,3,3,4,4,4,4,4,5,5,5,6,6,7) #input vector
                   , ltail=T,
                   over= NULL,
                   calc = NULL){
    #http://www.r-tutor.com/elementary-statistics/hypothesis-testing/upper-tail-test-population-mean-unknown-variance
    
    if (is.null(over)){over <- c(1:length(x))} 
    if (is.null(calc)){calc <- c(1:length(x))} 
    
    
    m <- mean(x[over])
    s <-sd(x[over])
    n <- length(x[over])
    
    #test statistic
    fx <- function(x) (m-x)/(s/sqrt(n))
    t <- sapply(x[calc], fx )
    
    #ttest
    fy <- function(x) pt(x, df=n-1, lower.tail = ltail)
    pvals <- sapply(t, fy)
    
    return(pvals)
    
}

#' MosCluster
#' 
#' Cluster a matrix
#'  
#' @param mx matrix (of intensity values)
#' @param method "clara" (from the cluster package)
#' @param ... additional arguments to the clustering method
#'
#' @importFrom cluster clara
#' 
#' @export
MosCluster <- function(method = "clara",
                       ...){
  #requireNamespace("cluster")
  res <- do.call(paste0(method), list(...))
  
  return(data.frame(cluster__clara = res$clustering))
  
}    
